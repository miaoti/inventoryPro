name: Deploy to GCP Debian with HTTPS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      gcp_instance_ip:
        description: 'GCP Instance IP Address (for reference)'
        required: true
        default: '129.146.49.129'
      gcp_ssh_user:
        description: 'SSH User for GCP Instance (for reference)'
        required: true
        default: 'gcp-github-actions-no-pass'

env:
  REGISTRY: ghcr.io
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  GCP_INSTANCE_IP: ${{ github.event.inputs.gcp_instance_ip || '129.146.49.129' }}

jobs:
  build-and-deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: üõ†Ô∏è Verify and Install Dependencies on Self-Hosted Runner
      run: |
        echo "üöÄ Verifying dependencies on self-hosted runner..."
        
        # Update package list and install dependencies
        sudo apt-get update -y
        sudo apt-get install -y --no-install-recommends apt-transport-https ca-certificates curl gnupg lsb-release git openssl
        
        # Install Docker if not present
        if ! [ -x "$(command -v docker)" ]; then
          echo "üîß Installing Docker..."
          curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update -y
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io
          sudo usermod -aG docker $USER
          echo "‚úÖ Docker installed. NOTE: A new shell session or restart is needed for group changes to apply. Using sudo."
        else
          echo "‚úÖ Docker is already installed."
        fi

        # Install Docker Compose if not present
        if ! [ -x "$(command -v docker-compose)" ]; then
          echo "üîß Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          echo "‚úÖ Docker Compose installed."
        else
          echo "‚úÖ Docker Compose is already installed."
        fi
        
        echo "‚úÖ Runner setup complete."

    - name: Set up environment variables
      run: |
        echo "Setting up environment variables..."
        cat > .env << EOF
        MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_DATABASE=inventory_db
        MYSQL_USER=inventory_user
        MYSQL_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
        MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
        NODE_ENV=production
        SPRING_PROFILES_ACTIVE=production
        NEXT_PUBLIC_API_URL=/api
        LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_MAIL=DEBUG
        EOF

    - name: Generate SSL certificates for HTTPS camera access
      run: |
        echo "üìú Generating SSL certificates for camera functionality..."
        
        # Create SSL directory if it doesn't exist
        mkdir -p nginx/ssl
        
        # Check if certificates already exist and are valid for the target IP
        CERT_VALID=false
        if [ -f "nginx/ssl/server.crt" ]; then
          if openssl x509 -in nginx/ssl/server.crt -checkend 86400 -noout 2>/dev/null; then
            if openssl x509 -in nginx/ssl/server.crt -text -noout | grep -q "CN=${{ env.GCP_INSTANCE_IP }}"; then
              echo "‚úÖ Valid SSL certificate for ${{ env.GCP_INSTANCE_IP }} already exists."
              CERT_VALID=true
            else
              echo "üîÑ IP address has changed. Regenerating certificate."
            fi
          else
            echo "üîÑ SSL certificate expired, regenerating..."
          fi
        fi
        
        # Generate new certificates if they don't exist, are invalid, or IP changed
        if [ "$CERT_VALID" = false ]; then
          echo "üîß Generating new SSL certificates for IP: ${{ env.GCP_INSTANCE_IP }}"
          rm -f nginx/ssl/server.*
          openssl genrsa -out nginx/ssl/server.key 2048
          openssl req -new -key nginx/ssl/server.key -out nginx/ssl/server.csr \
            -subj "/C=US/ST=State/L=City/O=Inventory-System/CN=${{ env.GCP_INSTANCE_IP }}"
          openssl x509 -req -days 365 \
            -in nginx/ssl/server.csr \
            -signkey nginx/ssl/server.key \
            -out nginx/ssl/server.crt
          chmod 600 nginx/ssl/server.key
          chmod 644 nginx/ssl/server.crt
          rm nginx/ssl/server.csr
          echo "‚úÖ SSL certificates generated successfully"
        fi

    - name: Stop existing containers and repair failed migration
      run: |
        echo "üßπ Comprehensive Docker cleanup to prevent ContainerConfig errors (preserving database data)..."
        
        # Stop all containers gracefully first
        sudo docker-compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
        
        # Force stop any remaining containers
        sudo docker stop $(sudo docker ps -aq) 2>/dev/null || true
        
        # Remove all containers (including exited ones)
        sudo docker rm $(sudo docker ps -aq) 2>/dev/null || true
        
        # Clean up networks
        sudo docker network prune -f 2>/dev/null || true
        
        # Clean up dangling images and build cache (but preserve volumes)
        sudo docker image prune -f 2>/dev/null || true
        sudo docker builder prune -f 2>/dev/null || true
        
        # Restart Docker service to clear any corruption
        echo "üîÑ Restarting Docker service to clear any corruption..."
        sudo systemctl restart docker
        sleep 10
        
        echo "üîç Checking for existing MySQL data volume..."
        if sudo docker volume ls | grep -q mysql_data; then
          echo "‚úÖ Found existing MySQL data volume - preserving database data"
          MYSQL_DATA_EXISTS=true
        else
          echo "‚ÑπÔ∏è No existing MySQL data volume found - will create fresh database"
          MYSQL_DATA_EXISTS=false
        fi
        
        echo "üöÄ Starting MySQL (preserving existing data if present)..."
        sudo docker-compose -f docker-compose.prod.yml up -d mysql
        sleep 30
        
        echo "‚úÖ Checking MySQL status..."
        sudo docker-compose -f docker-compose.prod.yml logs --tail=20 mysql
        
        echo "üîç Verifying MySQL database availability..."
        for i in {1..10}; do
          if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "SHOW DATABASES;" 2>/dev/null | grep -q "inventory_db"; then
            if [ "$MYSQL_DATA_EXISTS" = true ]; then
              echo "‚úÖ MySQL ready with existing data preserved"
            else
              echo "‚úÖ MySQL ready with fresh database created"
            fi
            break
          fi
          echo "‚è≥ Waiting for MySQL... ($i/10)"
          sleep 5
        done
        
        sudo docker-compose -f docker-compose.prod.yml stop mysql

    - name: Create database backup (production safety)
      run: |
        echo "üíæ Creating database backup before deployment..."
        
        # Start MySQL temporarily for backup
        sudo docker-compose -f docker-compose.prod.yml up -d mysql
        sleep 20
        
        # Check if database exists and has data
        if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "USE inventory_db; SHOW TABLES;" 2>/dev/null | grep -q "users\|items\|alerts"; then
          echo "üì¶ Database contains data - creating backup..."
          
          # Create backup directory
          mkdir -p ./backups
          
          # Create backup with timestamp
          BACKUP_FILE="./backups/inventory_db_backup_$(date +%Y%m%d_%H%M%S).sql"
          
          sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqldump -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} inventory_db > "$BACKUP_FILE" 2>/dev/null || echo "Backup creation had warnings"
          
          if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
            echo "‚úÖ Database backup created: $BACKUP_FILE"
            echo "üìä Backup file size: $(du -h $BACKUP_FILE | cut -f1)"
            
            # Keep only last 5 backups to save space
            ls -t ./backups/inventory_db_backup_*.sql | tail -n +6 | xargs -r rm
            echo "üßπ Cleaned up old backups (keeping last 5)"
          else
            echo "‚ö†Ô∏è Backup file seems empty or creation failed"
          fi
        else
          echo "‚ÑπÔ∏è No significant data found - skipping backup"
        fi
        
        sudo docker-compose -f docker-compose.prod.yml stop mysql

    - name: Apply database migrations and verify complete setup
      run: |
        echo "üîÑ Starting complete application for database migrations..."
        
        # Start all services for complete migration
        sudo docker-compose -f docker-compose.prod.yml up -d mysql
        sleep 20
        
        echo "üîç Waiting for MySQL to be ready..."
        for i in {1..12}; do
          if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} 2>/dev/null; then
            echo "‚úÖ MySQL is ready"
            break
          fi
          echo "‚è≥ Waiting for MySQL... ($i/12)"
          sleep 10
        done
        
        echo "üîç Checking current database state..."
        TABLES_COUNT=$(sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "USE inventory_db; SHOW TABLES;" 2>/dev/null | wc -l)
        if [ "$TABLES_COUNT" -gt 1 ]; then
          echo "‚úÖ Database already contains tables - existing data preserved"
          HAS_EXISTING_DATA=true
        else
          echo "‚ÑπÔ∏è Database is empty - will run full migrations"
          HAS_EXISTING_DATA=false
        fi
        
        echo "üöÄ Starting backend for Flyway migrations..."
        sudo docker-compose -f docker-compose.prod.yml up -d backend
        
        echo "‚è≥ Waiting for Flyway migrations to complete..."
        sleep 45
        
        echo "üìú Checking backend migration logs..."
        sudo docker-compose -f docker-compose.prod.yml logs --tail=50 backend | grep -E "(Flyway|Migration|Successfully|ERROR)" || echo "Checking full backend logs..."
        
        echo "üîç Verifying database tables..."
        sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        
        SELECT 'Database Tables:' as ' ';
        SHOW TABLES;
        
        SELECT 'Flyway Migration History:' as ' ';
        SELECT version, description, success, installed_on 
        FROM flyway_schema_history 
        ORDER BY installed_rank;
        " 2>/dev/null || echo "‚ö†Ô∏è Migration verification had issues"
        
        echo "üîß Ensuring owner account exists (idempotent operation)..."
        sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        
        -- Check if owner user already exists
        SET @user_exists = (SELECT COUNT(*) FROM users WHERE username = 'zoe');
        
        -- Create owner user if not exists (idempotent)
        INSERT INTO users (username, password, email, full_name, enabled, role, enable_email_alerts, enable_daily_digest, alert_email, created_at, updated_at) 
        SELECT 'zoe', '\$2a\$12\$2x2e3UQT/Zisuh0uNs6jVOVQdnBl0DrpUxvAvpTcglwD.iCItAqmi', 'zhongqi0728@gmail.com', 'Zoe (Owner)', TRUE, 'OWNER', TRUE, TRUE, 'zhongqi0728@gmail.com', NOW(), NOW()
        WHERE NOT EXISTS (SELECT 1 FROM users WHERE username = 'zoe');
        
        -- Update existing owner account settings if user exists
        UPDATE users SET 
          email = 'zhongqi0728@gmail.com',
          full_name = 'Zoe (Owner)',
          role = 'OWNER',
          enable_email_alerts = TRUE,
          enable_daily_digest = TRUE,
          alert_email = 'zhongqi0728@gmail.com',
          updated_at = NOW()
        WHERE username = 'zoe';
        
        -- Verify the owner account status
        SELECT 'Owner account status:' as info, username, email, role, enable_email_alerts, created_at
        FROM users 
        WHERE username = 'zoe';
        " 2>/dev/null || echo "Owner account setup completed with warnings"
        
        if [ "$HAS_EXISTING_DATA" = true ]; then
          echo "‚úÖ Database migrations completed - existing data preserved"
        else
          echo "‚úÖ Database migrations completed - fresh database initialized"
        fi

    - name: Verify source code structure
      run: |
        echo "Checking source code structure..."
        ls -la

    - name: Build application with correct configuration
      run: |
        echo "Building application with production settings and HTTPS support..."
        export DOCKER_BUILDKIT=1
        
        # Build with no cache to ensure fresh build with /api and HTTPS support
        sudo docker-compose -f docker-compose.prod.yml build --no-cache --pull \
          --build-arg NEXT_PUBLIC_API_URL=/api \
          --build-arg NODE_ENV=production

    - name: Start application services with HTTPS
      run: |
        echo "üöÄ Starting application services with HTTPS support and retry logic..."
        
        # Function to retry docker-compose up with cleanup on failure
        start_services_with_retry() {
          local attempt=1
          local max_attempts=3
          
          while [ $attempt -le $max_attempts ]; do
            echo "üîÑ Attempt $attempt/$max_attempts: Starting services..."
            
            if sudo docker-compose -f docker-compose.prod.yml up -d; then
              echo "‚úÖ Services started successfully on attempt $attempt"
              return 0
            else
              echo "‚ùå Attempt $attempt failed with ContainerConfig error"
              
              if [ $attempt -lt $max_attempts ]; then
                echo "üßπ Cleaning up before retry..."
                sudo docker-compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
                sudo docker system prune -f 2>/dev/null || true
                sleep 5
              fi
              
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå Failed to start services after $max_attempts attempts"
          return 1
        }
        
        # Try to start services with retry logic
        if ! start_services_with_retry; then
          echo "üÜò Emergency cleanup and restart..."
          sudo systemctl restart docker
          sleep 10
          sudo docker-compose -f docker-compose.prod.yml up -d || {
            echo "‚ùå Critical failure: Unable to start services"
            sudo docker-compose -f docker-compose.prod.yml logs
            exit 1
          }
        fi
        
        echo "‚úÖ Forcing nginx restart to pick up SSL certificates and config changes..."
        sleep 5
        sudo docker-compose -f docker-compose.prod.yml restart nginx || {
          echo "‚ö†Ô∏è Nginx restart failed, checking status..."
          sudo docker-compose -f docker-compose.prod.yml ps nginx
          sudo docker-compose -f docker-compose.prod.yml logs nginx --tail=20
        }
        sleep 10

    - name: Service Health Diagnostics
      run: |
        echo "üîç Comprehensive service diagnostics..."
        
        echo "üìä Docker system info:"
        sudo docker system df
        
        echo "üìã Container status:"
        sudo docker-compose -f docker-compose.prod.yml ps
        
        echo "üåê Network connectivity tests:"
        echo "Testing internal connectivity..."
        
        # Test each service individually
        echo "üîç Testing MySQL connectivity:"
        if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} 2>/dev/null; then
          echo "‚úÖ MySQL is accessible"
        else
          echo "‚ùå MySQL connection failed"
          sudo docker-compose -f docker-compose.prod.yml logs mysql --tail=10
        fi
        
        echo "üîç Testing Backend connectivity:"
        for i in {1..5}; do
          if curl -f http://localhost:8080/api/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is accessible at http://localhost:8080/api"
            break
          elif curl -f http://localhost:8080/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is accessible at http://localhost:8080"
            break
          else
            echo "‚è≥ Backend not ready yet... ($i/5)"
            sleep 10
          fi
        done
        
        echo "üîç Testing Frontend connectivity:"
        if curl -f http://localhost:3000 2>/dev/null; then
          echo "‚úÖ Frontend is accessible"
        else
          echo "‚ùå Frontend connection failed"
          sudo docker-compose -f docker-compose.prod.yml logs frontend --tail=10
        fi
        
        echo "üîç Testing Nginx HTTP:"
        if curl -f http://localhost:80 2>/dev/null; then
          echo "‚úÖ Nginx HTTP is accessible"
        else
          echo "‚ùå Nginx HTTP failed"
          sudo docker-compose -f docker-compose.prod.yml logs nginx --tail=10
        fi
        
        echo "üîç Testing Nginx HTTPS:"
        if curl --insecure -f https://localhost:443 2>/dev/null; then
          echo "‚úÖ Nginx HTTPS is accessible"
        else
          echo "‚ùå Nginx HTTPS failed"
        fi
        
        echo "üåç External accessibility test:"
        echo "Your application should be accessible at:"
        echo "HTTP:  http://${{ env.GCP_INSTANCE_IP }}"
        echo "HTTPS: https://${{ env.GCP_INSTANCE_IP }}"
        
        echo "üî• Firewall check:"
        echo "Checking if firewall allows web traffic..."
        sudo ufw status || echo "UFW not configured"
        
        echo "üì° Port accessibility from external:"
        timeout 5s nc -zv ${{ env.GCP_INSTANCE_IP }} 80 || echo "Port 80 may not be accessible externally"
        timeout 5s nc -zv ${{ env.GCP_INSTANCE_IP }} 443 || echo "Port 443 may not be accessible externally"

    - name: Wait for services to be ready
      run: |
        echo "Waiting for services to start..."
        sleep 20
        
        echo "Checking service health..."
        # Check MySQL
        for i in {1..12}; do
          if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} 2>/dev/null; then
            echo "‚úÖ MySQL is healthy"
            break
          fi
          echo "‚è≥ Waiting for MySQL... ($i/12)"
          sleep 10
        done

        # Check Backend (extended timeout for migrations)
        for i in {1..5}; do
          if curl -f http://localhost:8080/api/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is healthy (with /api context)"
            break
          elif curl -f http://localhost:8080/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is healthy (without /api context)"
            break
          fi
          echo "‚è≥ Waiting for Backend (migrations may be running)... ($i/5)"
          sleep 10
        done

        # Check Frontend
        for i in {1..5}; do
          if curl -f http://localhost:3000 2>/dev/null; then
            echo "‚úÖ Frontend is healthy"
            break
          fi
          echo "‚è≥ Waiting for Frontend... ($i/5)"
          sleep 10
        done

        # Check Nginx HTTP
        for i in {1..8}; do
          if curl -f http://localhost:80/health 2>/dev/null; then
            echo "‚úÖ Nginx HTTP is healthy"
            break
          fi
          echo "‚è≥ Waiting for Nginx HTTP... ($i/8)"
          sleep 10
        done

        # Check Nginx HTTPS
        for i in {1..8}; do
          # Use --insecure because we are using a self-signed certificate
          if curl --insecure -f https://localhost:443/health 2>/dev/null; then
            echo "‚úÖ Nginx HTTPS is healthy"
            break
          fi
          echo "‚è≥ Waiting for Nginx HTTPS... ($i/8)"
          sleep 10
        done

    - name: Debug Database Connection
      run: |
        echo "üîß Debugging database connection before verification..."
        echo "Checking MySQL container status:"
        sudo docker-compose -f docker-compose.prod.yml ps mysql
        
        echo "Checking MySQL container logs (last 20 lines):"
        sudo docker-compose -f docker-compose.prod.yml logs --tail=20 mysql
        
        echo "Testing MySQL connection with timeout:"
        timeout 10s sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} || echo "‚ùå MySQL ping failed or timed out"
        
        echo "Checking if database exists:"
        sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "SHOW DATABASES;" 2>/dev/null || echo "‚ùå Failed to list databases"
        
    - name: Final Database State Verification
      run: |
        echo "üîç Verifying final database state..."
        
        # Wait for MySQL to be completely ready before verification
        echo "‚è≥ Ensuring MySQL is fully ready for verification..."
        for i in {1..12}; do
          if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} 2>/dev/null; then
            echo "‚úÖ MySQL is ready for verification"
            break
          fi
          echo "‚è≥ Waiting for MySQL to be ready... ($i/12)"
          sleep 5
        done
        
        # Additional wait to ensure database is completely initialized
        sleep 10
        
        # Verify database connection and state
        echo "üîç Running database verification..."
        if sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "SELECT 1;" 2>/dev/null; then
          echo "‚úÖ Database connection successful"
          
          # Run the actual verification queries
          sudo docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
          USE inventory_db;
          
          SELECT 'All Database Tables:' as ' ';
          SHOW TABLES;
          
          SELECT 'Flyway Migration Status:' as ' ';
          SELECT COUNT(*) as total_migrations, 
                 SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_migrations,
                 SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failed_migrations
          FROM flyway_schema_history;
          
          SELECT 'Recent Migration History:' as ' ';
          SELECT version, description, success, installed_on 
          FROM flyway_schema_history 
          ORDER BY installed_rank DESC 
          LIMIT 5;
          
          SELECT 'Current Users and Roles:' as ' ';
          SELECT username, email, role, enable_email_alerts FROM users;
          
          SELECT 'Verifying Owner Account:' as ' ';
          SELECT IF(COUNT(*) = 1, 'SUCCESS', 'FAILURE') as status 
          FROM users WHERE username = 'zoe' AND role = 'OWNER';
          
          SELECT 'User Role Counts:' as ' ';
          SELECT role, COUNT(*) as count FROM users GROUP BY role;
          
          SELECT 'Database Health Check:' as ' ';
          SELECT 
            (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'inventory_db') as total_tables,
            (SELECT COUNT(*) FROM users) as total_users,
            (SELECT COUNT(*) FROM flyway_schema_history WHERE success = 1) as successful_migrations;
          " 2>/dev/null || echo "‚ö†Ô∏è Database verification completed with warnings"
        else
          echo "‚ùå Database connection failed - checking container status..."
          sudo docker-compose -f docker-compose.prod.yml ps
          sudo docker-compose -f docker-compose.prod.yml logs --tail=50 mysql
          echo "‚ö†Ô∏è Skipping database verification due to connection issues"
        fi

    - name: Display Application Logs for Debugging
      run: |
        echo "üìú Displaying application logs for debugging..."
        sudo docker-compose -f docker-compose.prod.yml logs --tail=150
        
    - name: Deployment Summary
      run: |
        echo "üéâ Deployment to ${{ env.GCP_INSTANCE_IP }} complete!"
        echo "Access your application at: https://${{ env.GCP_INSTANCE_IP }}"
        echo "Check the detailed logs above for verification." 