name: Deploy to GCP Debian with HTTPS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      gcp_instance_ip:
        description: 'GCP Instance IP Address'
        required: true
        default: '34.72.157.206'
      gcp_ssh_user:
        description: 'SSH User for GCP Instance'
        required: true
        default: 'ubuntu'
      gcp_ssh_private_key:
        description: 'SSH Private Key for GCP Instance'
        required: true

env:
  REGISTRY: ghcr.io
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  GCP_INSTANCE_IP: ${{ github.event.inputs.gcp_instance_ip ||  '34.72.157.206' }}

jobs:
  setup-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: üõ†Ô∏è Setup Debian Server for Deployment
      uses: appleboy/ssh-action@master
      with:
        host: ${{ env.GCP_INSTANCE_IP }}
        username: ${{ github.event.inputs.gcp_ssh_user || 'ubuntu' }}
        key: ${{ github.event.inputs.gcp_ssh_private_key || secrets.GCP_SSH_PRIVATE_KEY }}
        script: |
          echo "üöÄ Starting setup on Debian instance..."
          
          # Update package list and install dependencies
          sudo apt-get update -y
          sudo apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release git
          
          # Install Docker if not present
          if ! [ -x "$(command -v docker)" ]; then
            echo "üîß Installing Docker..."
            sudo curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update -y
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io
            sudo usermod -aG docker ${{ github.event.inputs.gcp_ssh_user || 'ubuntu' }}
            echo "‚úÖ Docker installed."
          else
            echo "‚úÖ Docker is already installed."
          fi

          # Install Docker Compose if not present
          if ! [ -x "$(command -v docker-compose)" ]; then
            echo "üîß Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            echo "‚úÖ Docker Compose installed."
          else
            echo "‚úÖ Docker Compose is already installed."
          fi
          
          echo "‚úÖ Debian server setup complete."

  build-and-deploy:
    needs: setup-and-deploy
    runs-on: self-hosted
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up environment variables
      run: |
        echo "Setting up environment variables..."
        cat > .env << EOF
        MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_DATABASE=inventory_db
        MYSQL_USER=inventory_user
        MYSQL_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
        MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
        NODE_ENV=production
        SPRING_PROFILES_ACTIVE=production
        NEXT_PUBLIC_API_URL=/api
        EOF

    - name: Generate SSL certificates for HTTPS camera access
      run: |
        echo "üìú Generating SSL certificates for camera functionality..."
        
        # Create SSL directory if it doesn't exist
        mkdir -p nginx/ssl
        
        # Check if certificates already exist and are valid for the target IP
        CERT_VALID=false
        if [ -f "nginx/ssl/server.crt" ]; then
          if openssl x509 -in nginx/ssl/server.crt -checkend 86400 -noout 2>/dev/null; then
            if openssl x509 -in nginx/ssl/server.crt -text -noout | grep -q "CN=${{ env.GCP_INSTANCE_IP }}"; then
              echo "‚úÖ Valid SSL certificate for ${{ env.GCP_INSTANCE_IP }} already exists."
              CERT_VALID=true
            else
              echo " IP address has changed. Regenerating certificate."
            fi
          else
            echo "üîÑ SSL certificate expired, regenerating..."
          fi
        fi
        
        # Generate new certificates if they don't exist, are invalid, or IP changed
        if [ "$CERT_VALID" = false ]; then
          echo "üîß Generating new SSL certificates for IP: ${{ env.GCP_INSTANCE_IP }}"
          rm -f nginx/ssl/server.*
          openssl genrsa -out nginx/ssl/server.key 2048
          openssl req -new -key nginx/ssl/server.key -out nginx/ssl/server.csr \
            -subj "/C=US/ST=State/L=City/O=Inventory-System/CN=${{ env.GCP_INSTANCE_IP }}"
          openssl x509 -req -days 365 \
            -in nginx/ssl/server.csr \
            -signkey nginx/ssl/server.key \
            -out nginx/ssl/server.crt
          
          # Set proper permissions
          chmod 600 nginx/ssl/server.key
          chmod 644 nginx/ssl/server.crt
          
          # Clean up CSR file
          rm nginx/ssl/server.csr
          
          echo "‚úÖ SSL certificates generated successfully"
          echo "Certificate info:"
          openssl x509 -in nginx/ssl/server.crt -text -noout | grep -E "(Subject:|Not Before|Not After)"
        fi

    - name: Set up SSH access for debugging
      run: |
        echo "Setting up SSH access for post-deployment debugging..."
        mkdir -p ~/.ssh
        echo "${{ secrets.ORACLE_SSH_KEY }}" > ~/.ssh/oracle_key
        chmod 600 ~/.ssh/oracle_key
        echo "SSH key configured for oracle_key"
        
        # Add Oracle instance to known hosts
        ssh-keyscan -H ${{ env.GCP_INSTANCE_IP }} >> ~/.ssh/known_hosts
        
        # Test SSH connection with verbose output for debugging
        echo "Testing SSH connection..."
        ssh -i ~/.ssh/oracle_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ github.event.inputs.gcp_ssh_user || 'ubuntu' }}@${{ env.GCP_INSTANCE_IP }} "echo 'SSH connection successful'" 2>&1 || {
          echo "SSH test failed, but continuing deployment"
          echo "To fix SSH access:"
          echo "1. Extract public key from your private key:"
          echo "   ssh-keygen -y -f ssh-key-2025-06-06.key > ssh-key-2025-06-06.key.pub"
          echo "2. Add the public key to your Oracle instance:"
          echo "   cat ssh-key-2025-06-06.key.pub >> ~/.ssh/authorized_keys"
        }

    - name: Stop existing containers and repair failed migration
      run: |
        echo "Stopping existing containers..."
        docker stop $(docker ps -aq) 2>/dev/null || true
        docker system prune -f
        
        echo "Starting MySQL to repair failed migration..."
        docker-compose -f docker-compose.prod.yml up -d mysql
        sleep 20
        
        echo "Repairing failed migrations..."
        docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        DELETE FROM flyway_schema_history WHERE version = '17' AND success = 0;
        DELETE FROM flyway_schema_history WHERE version = '19' AND success = 0;
        " 2>/dev/null || echo "Migration repair attempted"
        
        docker-compose -f docker-compose.prod.yml stop mysql

    - name: Apply database migrations
      run: |
        echo "üîÑ Applying database migrations..."
        
        # Start MySQL for migration
        docker-compose -f docker-compose.prod.yml up -d mysql
        sleep 20
        
        echo "Applying V19 migration to create owner account..."
        docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        
        -- Create owner user if not exists (V19 migration)
        INSERT INTO users (username, password, email, full_name, enabled, role, enable_email_alerts, enable_daily_digest, alert_email, created_at, updated_at) 
        VALUES ('zoe', '$2a$12$2x2e3UQT/Zisuh0uNs6jVOVQdnBl0DrpUxvAvpTcglwD.iCItAqmi', 'zhongqi0728@gmail.com', 'Zoe (Owner)', TRUE, 'OWNER', TRUE, TRUE, 'zhongqi0728@gmail.com', NOW(), NOW())
        ON DUPLICATE KEY UPDATE 
          password = VALUES(password),
          email = VALUES(email),
          full_name = VALUES(full_name),
          role = VALUES(role),
          enable_email_alerts = VALUES(enable_email_alerts),
          enable_daily_digest = VALUES(enable_daily_digest),
          alert_email = VALUES(alert_email),
          updated_at = NOW();
        
        -- Verify the owner account was created/updated
        SELECT 'Owner account status:' as info, username, email, role, enable_email_alerts 
        FROM users 
        WHERE username = 'zoe';
        " 2>/dev/null || echo "Migration execution completed with warnings"
        
        echo "‚úÖ Database migrations applied"
        
        docker-compose -f docker-compose.prod.yml stop mysql

    - name: Verify source code structure
      run: |
        echo "Checking source code structure..."
        echo "Backend (Spring Boot):"
        if [ -f ./inventory/pom.xml ]; then
          echo "‚úÖ Found Spring Boot backend"
          ls -la ./inventory/
        else
          echo "‚ùå No Spring Boot backend found"
        fi
        
        echo "Frontend (Next.js):"
        if [ -f ./inventory_frontend/package.json ]; then
          echo "‚úÖ Found Next.js frontend"
          ls -la ./inventory_frontend/
        else
          echo "‚ùå No Next.js frontend found"
        fi
        
        echo "SSL Certificates:"
        if [ -f ./nginx/ssl/server.crt ] && [ -f ./nginx/ssl/server.key ]; then
          echo "‚úÖ SSL certificates are ready"
          ls -la ./nginx/ssl/
        else
          echo "‚ùå SSL certificates missing"
        fi

    - name: Build application with correct configuration
      run: |
        echo "Building application with production settings and HTTPS support..."
        export DOCKER_BUILDKIT=1
        
        # Build with no cache to ensure fresh build with /api and HTTPS support
        docker-compose -f docker-compose.prod.yml build --no-cache --pull \
          --build-arg NEXT_PUBLIC_API_URL=/api \
          --build-arg NODE_ENV=production

    - name: Start application services with HTTPS
      run: |
        echo "Starting application services with HTTPS support..."
        docker-compose -f docker-compose.prod.yml up -d
        
        echo "Force restarting nginx to pick up SSL certificates and config changes..."
        sleep 5
        docker-compose -f docker-compose.prod.yml restart nginx
        sleep 10

    - name: Wait for services to be ready
      run: |
        echo "Waiting for services to start..."
        sleep 20
        
        echo "Checking service health..."
        # Check MySQL
        for i in {1..12}; do
          if docker-compose -f docker-compose.prod.yml exec -T mysql mysqladmin ping -h localhost -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} 2>/dev/null; then
            echo "‚úÖ MySQL is healthy"
            break
          fi
          echo "‚è≥ Waiting for MySQL... ($i/12)"
          sleep 10
        done

        # Check Backend (extended timeout for migrations)
        for i in {1..5}; do
          if curl -f http://localhost:8080/api/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is healthy (with /api context)"
            break
          elif curl -f http://localhost:8080/actuator/health 2>/dev/null; then
            echo "‚úÖ Backend is healthy (without /api context)"
            break
          fi
          echo "‚è≥ Waiting for Backend (migrations may be running)... ($i/5)"
          sleep 10
        done

        # Check Frontend
        for i in {1..5}; do
          if curl -f http://localhost:3000 2>/dev/null; then
            echo "‚úÖ Frontend is healthy"
            break
          fi
          echo "‚è≥ Waiting for Frontend... ($i/5)"
          sleep 10
        done

        # Check Nginx HTTP
        for i in {1..8}; do
          if curl -f http://localhost:80/health 2>/dev/null; then
            echo "‚úÖ Nginx HTTP is healthy"
            break
          fi
          echo "‚è≥ Waiting for Nginx HTTP... ($i/8)"
          sleep 10
        done
        
        # Check Nginx HTTPS
        for i in {1..8}; do
          # Use --insecure because we are using a self-signed certificate
          if curl --insecure -f https://localhost:443/health 2>/dev/null; then
            echo "‚úÖ Nginx HTTPS is healthy"
            break
          fi
          echo "‚è≥ Waiting for Nginx HTTPS... ($i/8)"
          sleep 10
        done

    - name: Verify database migration and owner account creation
      run: |
        echo "üîç Verifying database migration and owner account creation..."
        
        # Wait for backend to be fully ready for database operations
        sleep 10
        
        echo "Checking database tables and users..."
        docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        
        -- Check if users table exists and has the correct structure
        DESCRIBE users;
        
        -- Check existing users
        SELECT username, email, role, enable_email_alerts FROM users;
        
        -- Verify owner account exists
        SELECT 'Owner account verification:' as check_type, 
               COUNT(*) as count,
               CASE WHEN COUNT(*) > 0 THEN 'SUCCESS' ELSE 'FAILED' END as status
        FROM users 
        WHERE username = 'zoe' AND role = 'OWNER' AND email = 'zhongqi0728@gmail.com';
        
        -- Check total user count by role
        SELECT role, COUNT(*) as count FROM users GROUP BY role;
        " 2>/dev/null || echo "‚ö†Ô∏è Database verification failed, but continuing deployment"
        
        echo "‚úÖ Database verification completed"

    - name: Verify nginx configuration and SSL setup
      run: |
        echo "üîç Checking nginx configuration and SSL setup..."
        
        # Wait for nginx to be stable
        for i in {1..10}; do
          if docker ps | grep inventory_nginx_prod | grep -q "Up"; then
            echo "‚úÖ Nginx container is running"
            break
          fi
          echo "‚è≥ Waiting for nginx container to be stable... ($i/10)"
          sleep 5
        done
        
        # Test nginx configuration
        echo "Testing nginx config syntax:"
        if docker exec inventory_nginx_prod nginx -t 2>/dev/null; then
          echo "‚úÖ Nginx configuration is valid"
        else
          echo "‚ö†Ô∏è Nginx configuration test failed, but continuing..."
        fi
        
        # Check SSL certificate mounting
        echo "Checking SSL certificate availability in container:"
        if docker exec inventory_nginx_prod test -f /etc/nginx/ssl/server.crt; then
          echo "‚úÖ SSL certificate mounted correctly"
          docker exec inventory_nginx_prod ls -la /etc/nginx/ssl/
        else
          echo "‚ùå SSL certificate not found in container"
        fi
        
        # Show nginx configuration sample
        echo "Sample nginx configuration:"
        docker exec inventory_nginx_prod cat /etc/nginx/nginx.conf | head -30 || echo "Could not read config"

    - name: Final deployment verification with HTTPS
      run: |
        echo "üîç Final deployment verification with HTTPS support..."
        echo "Container status:"
        docker-compose -f docker-compose.prod.yml ps
        
        echo "Testing endpoints:"
        echo "HTTP main site (port 80):"
        curl -I http://localhost:80 && echo "‚úÖ HTTP site OK" || echo "‚ùå HTTP site FAILED"
        
        echo "HTTPS main site (port 443):"
        curl -k -I https://localhost:443 && echo "‚úÖ HTTPS site OK" || echo "‚ùå HTTPS site FAILED"
        
        echo "HTTP to HTTPS redirect test for scanner:"
        HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:80/scanner)
        if [ "$HTTP_RESPONSE" = "301" ]; then
          echo "‚úÖ Scanner HTTP to HTTPS redirect working (HTTP 301)"
        else
          echo "‚ö†Ô∏è Scanner redirect not working (got HTTP $HTTP_RESPONSE)"
        fi
        
        echo "HTTPS scanner page:"
        curl -k -I https://localhost:443/scanner && echo "‚úÖ HTTPS scanner OK" || echo "‚ùå HTTPS scanner FAILED"
        
        echo "Frontend (port 3000):"
        curl -I http://localhost:3000 && echo "‚úÖ Frontend OK" || echo "‚ùå Frontend FAILED"  
        
        echo "Backend (port 8080):"
        curl -I http://localhost:8080/api/actuator/health && echo "‚úÖ Backend OK" || echo "‚ùå Backend FAILED"
        
        echo "üéâ Deployment Summary:"
        if curl -s http://localhost:80 >/dev/null && curl -k -s https://localhost:443 >/dev/null; then
          echo "‚úÖ SUCCESS: Your inventory application is live with HTTPS support!"
          echo "üåê HTTP Access: http://${{ env.GCP_INSTANCE_IP }}"
          echo "üîí HTTPS Access: https://${{ env.GCP_INSTANCE_IP }}"
          echo "üì± Camera Scanner: https://${{ env.GCP_INSTANCE_IP }}/scanner (HTTPS required for camera)"
          echo "üìã Other Pages: Work on both HTTP and HTTPS"
          echo "üîß Backend API: Accessible via both protocols"
          echo "üíæ Database: MySQL with your schema"
          echo ""
          echo "üì∑ Camera Access Instructions:"
          echo "1. Visit: http://${{ env.GCP_INSTANCE_IP }}/scanner (will auto-redirect to HTTPS)"
          echo "2. Accept the self-signed certificate warning"
          echo "3. Camera should now work properly!"
        else
          echo "‚ùå Deployment verification failed - running enhanced diagnostics..."
          echo "=== Nginx logs ==="
          docker-compose -f docker-compose.prod.yml logs nginx --tail=30
          echo "=== Frontend logs ==="
          docker-compose -f docker-compose.prod.yml logs frontend --tail=10
          echo "=== SSL Certificate check ==="
          docker exec inventory_nginx_prod openssl x509 -in /etc/nginx/ssl/server.crt -text -noout | head -20 || echo "SSL cert check failed"
          echo "=== Network connectivity test ==="
          echo "Testing internal connectivity:"
          docker-compose -f docker-compose.prod.yml exec nginx curl -I http://frontend:3000 || echo "Nginx -> Frontend failed"
          exit 1
        fi

    - name: Cleanup on failure
      if: failure()
      run: |
        echo "üö® Deployment failed, showing debug information..."
        echo "Container status:"
        docker-compose -f docker-compose.prod.yml ps
        
        echo "Recent logs:"
        echo "=== Frontend logs ==="
        docker-compose -f docker-compose.prod.yml logs frontend --tail=10
        echo "=== Backend logs ==="
        docker-compose -f docker-compose.prod.yml logs backend --tail=10
        echo "=== Nginx logs ==="
        docker-compose -f docker-compose.prod.yml logs nginx --tail=20
        
        echo "=== SSL Setup Debug ==="
        echo "SSL directory contents:"
        ls -la nginx/ssl/ 2>/dev/null || echo "No SSL directory"
        echo "SSL files in container:"
        docker exec inventory_nginx_prod ls -la /etc/nginx/ssl/ 2>/dev/null || echo "No SSL files in container"

    - name: Final Database State Verification
      run: |
        echo "üîç Verifying final database state..."
        docker-compose -f docker-compose.prod.yml exec -T mysql mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
        USE inventory_db;
        
        echo 'Current Users and Roles:';
        SELECT username, email, role, enable_email_alerts FROM users;
        
        echo 'Verifying Owner Account:';
        SELECT IF(COUNT(*) = 1, 'SUCCESS', 'FAILURE') as status 
        FROM users WHERE username = 'zoe' AND role = 'OWNER';
        
        echo 'User Role Counts:';
        SELECT role, COUNT(*) as count FROM users GROUP BY role;
        "
        
    - name: Display Application Logs
      run: |
        echo "üìú Displaying application logs..."
        docker-compose -f docker-compose.prod.yml logs --tail=100
        
    - name: Deployment Summary
      run: |
        echo "üéâ Deployment to ${{ env.GCP_INSTANCE_IP }} complete!"
        echo "Access your application at: https://${{ env.GCP_INSTANCE_IP }}"
        echo "Check the detailed logs above for verification." 